# coursera

public class shutDownHooksDemo {
    public static void main(String[] args) {
        for(int i=0;i<5;i++)
        {
            try {
                if(i==4) {
                    System.out.println("Inside Try Block.Exiting without executing Finally block.");
                    System.exit(0);
                }
            }
            finally {
                System.out.println("Inside Finally Block.");
            }
        }
    }
فرادرس فرادرس
جستجوی مطالب ...
 برنامه نویسی
نمونه کد جاوا — نمونه کدهای کاربردی برای برنامه نویسان جاوا
آخرین به‌روزرسانی: ۳ اسفند ۱۳۹۹
زمان مطالعه: ۳۷ دقیقهنمونه کد جاوا
جاوا یکی از محبوب‌ترین زبان‌های برنامه‌نویسی است و در حوزه وب‌اپلیکیشن، اپلیکیشن‌های ویندوزی، موبایل، شبکه، کالاهای مصرفی الکترونیک، دستگاه‌های گیرنده دیجیتال و تقریباً همه جا حضور دارد. جاوا اینک روی بیش از 3 میلیارد دستگاه اجرا می‌شود. بر اساس گزارش اوراکل هم اینک بیش از 5 میلیارد جاوا کارت در حال استفاده هستند. بیش از 9 میلیون توسعه‌دهنده به زبان جاوا کدنویسی می‌کنند و محبوبیت زیادی میان توسعه‌دهندگان دارد و به یکی از رایج‌ترین پلتفرم‌های توسعه تبدیل شده است. در این مطلب به بررسی انواع مختلفی از نمونه کد جاوا و الگوریتم‌های کاربردی این زبان برنامه‌نویسی می‌پردازیم.

فهرست مطالب این نوشته
تاریخچه جاوا
اصطلاحات جاوا
ویژگی‌های اصلی زبان جاوا
نکات، ترفندها و نمونه کد جاوا
الگوریتم‌ها و برنامه‌های کاربردی جاوا
سخن پایانی
تاریخچه جاوا
جاوا از سوی شرکت «سان مایکروسیستمز» (Sun Microsystems) در سال 1991 توسعه یافت و متعاقباً از سوی شرکت «اوراکل» (Oracle) خریداری شد. این پلتفرم توسط «جیمز گاسلنیگ» (James Gosling) و «پاتریک ناتون» (Patrick Naughton) توسعه یافته است. جاوا یک زبان ساده برنامه‌نویسی است که موجب شده نوشتن، کامپایل کردن و دیباگ برنامه‌ها آسان شود. با استفاده از جاوا می‌توان کد‌های با قابلیت استفاده مجدد و برنامه‌های ماژولار ساخت.

جاوا مبتنی بر کلاس و در واقع یک زبان شیء‌گرا است و طوری طراحی شده که تا حد امکان وابستگی‌های پیاده‌سازی کمی داشته باشد. جاوا زبان برنامه‌نویسی چندمنظوره است و توسعه‌دهندگان با بهره‌گیری از آن می‌توانند یک بار کد بنویسند و آن را هر کجا اجرا کند. برنامه‌های جاوا کامپایل شده و روی همه پلتفرم‌هایی که از جاوا پشتیبانی کنند، اجرا می‌شوند. اپلیکیشن‌های جاوا به «بایت کد» (Byte Code) کامپایل می‌شوند که می‌تواند روی هر ماشین مجازی جاوا اجرا شود. ساختار جاوا شبیه زبان‌های ++c/c است.

در 13 نوامبر سال 2006 شرکت سان اغلب کدهای ماشین مجازی جاوا را به صورت متن-باز و رایگان عرضه کرد. در 9 می 2007 این شرکت این فرایند را تکمیل کرده و همه کد JVM را تحت شرایط توزیع متن-باز عرضه کرد.

نمونه کد جاوا

اصطلاحات جاوا
برای این که شروع به یادگیری جاوا بکنید، قبلاً باید با برخی اصطلاحاتی که در این پلتفرم رواج دارند، آشنا شوید.

ماشین مجازی جاوا (Java Virtual Machine | JVM): هر برنامه جاوا سه فاز دارد. این برنامه ابتدا نوشته می‌شود، سپس کامپایل می‌شود و در نهایت اجرا خواهد شد. مرحله نوشتن برنامه از سوی توسعه‌دهندگان جاوا انجام می‌یابد. فرایند کامپایل کد از سوی کامپایلر JAVAC اجرا می‌شود که کامپایلر اصلی جاوا است و شامل کیت توسعه جاوا (JDK) است. این کامپایلر برنامه جاوا را دریافت کرده و بایت کد را به عنوان خروجی تولید می‌کند.
در مرحله اجرای یک برنامه جاوا، JVM بایت کد تولید شده از سوی کامپایلر را اجرا می‌کند. بدین ترتیب متوجه می‌شویم که وظیفه ماشین مجازی جاوا، اجرای بایت کد تولید شده از سوی کامپایلر است. هر سیستم عامل یک JVM متفاوت دارد، اما خروجی تولید شده پس از اجرای بایت کد روی همه سیستم‌های عامل مختلف، یکسان است. به همین دلیل است که جاوا یک زبان مستقل از پلتفرم محسوب می‌شود.
بایت کد (Bytecode): چنان که توضیح دادیم کامپایلر JAVAC سورس کد جاوا را به بایت کد کامپایل می‌کند، به طوری که JVM بتواند آن را اجرا کند. این بایت کد به صورت فایل class. ذخیره می‌شوند. برای مشاهده بایت کد باید از دی‌اسمبلرهایی مانند ‌javap استفاده کنید.
کیت توسعه جاوا (Java Development Kit | JDK): کیت توسعه جاوا چنان که از نامش برمی‌آید یک کیت توسعه کامل است که همه چیز از کامپایلر تا «محیط زمان اجرای جاوا» (JRE)، دیباگرهای جاوا، مستندات جاوا و غیره را شامل می‌شود. برای این که یک برنامه جاوا اجرا شود باید JDK را رویی رایانه نصب کنیم تا امکان نوشتن، کامپایل و اجرای برنامه‌های جاوا را بیابیم.
محیط زمان اجرای جاوا (Java Runtime Environment | JRE): JRE زیرمجموعه JDK است که در بخش قبل توضیح دادیم. با نصب JRE روی رایانه می‌توانیم یک برنامه جاوا را اجرا کنیم، اما نمی‌توانیم آن را کامپایل کنیم. JRE شامل یک مرورگر، JVM، پشتیبانی از اپلت و پلاگین‌ها است. بنابراین برای اجرای برنامه جاوا به JRE نیاز داریم.
گاربج کلکتور (Garbage Collector): برنامه‌نویسان در محیط جاوا امکان حذف اشیا را ندارند. JVM برای حذف اشیا و به دست آوردن مجدد حافظه از ابزاری به نام Garbage Collector بهره می‌گیرد. این ابزار اشیایی که ارجاعی به آن‌ها وجود ندارد را حذف می‌کند. بدین ترتیب جاوا با بر عهده گرفتن وظیفه مدیریت حافظه، موجب شده که کار برنامه‌نویسان آسان‌تر شود. با این حال برنامه‌نویس‌ها باید در مورد شیوه کدنویسی خود مراقبت‌های به عمل آورند و در مواردی که به شیئی نیاز ندارند آن را ارجاع زدایی کنند تا از سوی Garbage Collector حذف شود، زیرا این ابزار نمی‌تواند اشیایی که هنوز ارجاعی در حافظه دارند را جمع کند.
مسیر کلاس (ClassPath): ClassPath در واقع یک مسیر فایل است که محیط زمان اجرای جاوا و کامپایلر جاوا در آن به دنبال بارگذاری فایل‌های class. می‌گردند. به طور پیش‌فرض JDK کتابخانه‌های زیادی دارد. اگر می‌خواهید کتابخانه‌های اکسترنال را نیز بگنجانید، باید آن‌ها را به ClassPath اضافه کنید.
نمونه کد جاوا

ویژگی‌های اصلی زبان جاوا
در این بخش برخی قابلیت‌ها و ویژگی‌های عمده زبان برنامه‌نویسی جاوا را اجمالاً مرور می‌کنیم.

جاوا مستقل از پلتفرم است: کامپایلر جاوا سورس کد را به بایت کد تبدیل می‌کند و در ادامه JVM این بایت کد تولید شده از سوی کامپایلر را اجرا خواهد کرد. این بایت کد می‌تواند روی هر پلتفرمی چه ویندوز، لینوکس، مک‌اواس و یا غیره اجرا شود. بنابراین اگر کامپایلر برنامه‌ای را روی ویندوز کامپایل کند، می‌توانیم آن را روی لینوکس اجرا کنیم و یا به طور عکس عمل نماییم. هر سیستم عامل یک JVM متفاوت دارد، اما خروجی تولید شده از سوی همه سیستم‌های عامل پس از اجرای بایت کد یکسان خواهد بود. از این رو جاوا را یک زبان مستقل از پلتفرم می‌نامیم.
جاوا زبان شیءگرا است: زبان جاوا به عنوان یک زبان شیءگرایی واجد خصوصیات زیر است:
انتزاع (Abstraction)
کپسوله‌سازی (Encapsulation)
وراثت (Inheritance)
چندریختی (Polymorphism)
جاوا ساده است: جاوا یکی از زبان‌های ساده است، زیرا قابلیت‌های پیچیده‌ای مانند اشاره‌گر، اورلود عملگر، وراثت چندگانه، تخصیص صریح حافظه ندارد.
جاوا پایدار است: زبان جاوا دارای ثبات و پایداری است، زیرا طوری توسعه یافته که تلاش زیادی برای بررسی خطاها در نخستین مراحل کار انجام دهد. به همین جهت است که کامپایلر جاوا می‌تواند حتی آن خطاهایی را که شناسایی‌شان در زبان‌های دیگر برنامه‌نویسی آسان نیست هم شناسایی کند. قابلیت‌های اصلی جاوا که موجب ثبات آن شده گاربج کلکتور، مدیریت استثنا و تخصیص حافظه است.
جاوا امن است: ما در جاوا اشاره‌گر نداریم و از این رو نمی‌توانیم به آرایه‌ها در خارج از دامنه‌شان دسترسی پیدا کنیم، یعنی در صورتی که چنین تلاشی بکنیم، استثنای ArrayIndexOutOfBoundsException مشاهده می‌شود. به همین دلیل است که امکان سوءاستفاده از چند نقص امنیتی رایج مانند stack corruption یا سرریز بافر در جاوا وجود ندارد.
جاوا توزیع یافته است: امکان ساخت اپلیکیشن‌های توزیع یافته با استفاده از زبان برنامه‌نویسی جاوا وجود دارد. احضار متد ریموت و Enterprise Java Beans برای ایجاد اپلیکیشن‌های توزیع یافته در جاوا است. برنامه‌های جاوا می‌توانند به آسانی روی یک یا چند سیستم توزیع یابند و از طریق اتصال اینترنتی با همدیگر ارتباط بگیرند.
جاوا چندنخی است: جاوا از «چندنخی» (Multithreading) پشتیبانی می‌کند. این یک قابلیت جاوا است که امکان اجرای موازی دو یا چند بخش از برنامه را برای بیشینه بهره‌گیری از پردازنده فراهم می‌سازد.
جاوا پرتابل است: چنان که می‌دانیم کد جاوا که روی یک ماشین نوشته می‌شود، می‌تواند روی دستگاه‌های دیگر هم اجرا شود. قابلیت مستقل از پلتفرم جاوا به این معنی است که بایت کد مستقل از پلتفرم می‌تواند روی هر پلتفرمی اجرا شود.
لازم است قبل از ادامه دادن این مطلب یادآور شویم که پیش از این در مجله فرادرس مقاله‌ای با عنوان «زبان برنامه نویسی جاوا (Java) — از صفر تا صد» به انتشار رسیده است که به صورت مفصل و با جزئیات کامل به زبان برنامه‌نویسی جاوا پرداخته و آن را به کامل‌ترین شکل ممکن معرفی کرده است. پس اگر مشتاق هستید در مورد این زبان بیشتر یاد بگیرید، توصیه می‌کنیم این مطلب را حتماً مطالعه کنید.

نمونه کد جاوا

نکات، ترفندها و نمونه کد جاوا
در این بخش از مقاله نمونه کد جاوا به معرفی برخی نکات و ترفندهای مهم که در مراحل ابتدایی یادگیری این زبان باید رعایت کنید می‌پردازیم.

به جای Null کالکشن خالی بازگردانید
اگر برنامه‌ای یک کالکشن بازگرداند که هیچ مقداری ندارد، باید مطمئن شوید که یک کالکشن خالی و نه Null بازگشت می‌یابد. به این ترتیب دیگر لازم نیست مقدار زیادی کدهای if…else روی عناصر Null اجرا کنید.

public class getLocationName {
    return (null==cityName ? "": cityName);
}
از رشته‌ها با دقت استفاده کنید
اگر دو رشته با استفاده از عملگر (+) در یک حلقه for به هم الحاق شوند، یک هر بار «شیء رشته» (String Object) جدید ایجاد می‌شود. این کار موجب هدر رفتن حافظه و کاهش عملکرد زمانی می‌شود. همچنین در زمان وهله‌سازی از شیء رشته، نباید از سازنده‌ها استفاده کنید و باید این وهله‌سازی به صورت مستقیم انجام یابد. به مثال زیر توجه کنید:

//Slower Instantiation
String bad = new String("Yet another string object");
      
//Faster Instantiation
String good = "Yet another string object"
از ایجاد اشیای غیرضروری اجتناب کنید
یکی از پرهزینه‌ترین انواع عملیات از نظر مصرف حافظه در جاوا عملیات ایجاد شیء است. از این رو توصیه شده که شیء‌ها تنها در صورت لزوم ساخته یا وهله‌سازی شوند. در کد زیر نمونه‌ای از این موضوع را مشاهده می‌کنید:

import java.util.ArrayList;
import java.util.List;
 
public class Employees {
 
    private List Employees;
 
    public List getEmployees() {
 
        //initialize only when required
        if(null == Employees) {
            Employees = new ArrayList();
        }
        return Employees;
    }
}
مسئله دشوار انتخاب Array یا ArrayList
در اغلب اوقات توسعه‌دهندگان در مورد انتخاب یکی از ساختمان‌های داده Array و ArrayList دچار تردید می‌شوند. هر دوی این موارد نقاط ضعف و قوت خاص خود را دارند. انتخاب یکی از این دو در عمل به الزامات شما بستگی دارد.

import java.util.ArrayList;
 
public class arrayVsArrayList {
 
    public static void main(String[] args) {
        int[] myArray = new int[6];
        myArray[7]= 10; // ArraysOutOfBoundException
 
        //Declaration of ArrayList. Add and Remove of elements is easy.
        ArrayList<Integer> myArrayList = new ArrayList<>();
        myArrayList.add(1);
        myArrayList.add(2);
        myArrayList.add(3);
        myArrayList.add(4);
        myArrayList.add(5);
        myArrayList.remove(0);
         
        for(int i = 0; i < myArrayList.size(); i++) {
        System.out.println("Element: " + myArrayList.get(i));
        }
         
        //Multi-dimensional Array 
        int[][][] multiArray = new int [3][3][3]; 
    }
}
آرایه‌‌ها دارای اندازه ثابتی هستند، اما لیست‌آرایه‌ها اندازه متغیری دارند. از آنجا که اندازه آرایه ثابت است حافظه‌ی آن در زمان اعلان متغیر از نوع array تخصیص می‌یابد. از این رو آرایه‌ها عملکرد بسیار سریعی دارند. از سوی دیگر، اگر اندازه داده‌ها را از پیش ندانیم، در این صورت قرار دادن داده‌های بیش از ظرفیت آرایه موجب بروز استثنای ArrayOutOfBoundException می‌شود و درج موارد کمتر هم موجب هدر رفتن حافظه خواهد شد.

حذف و اضافه کردن عناصر به ArrayList آسان‌تر از Array است.
آرایه می‌تواند چندبعدی باشد، اما ArrayList تنها یک بعد می‌توان داشته باشد.
گاهی اوقات Finally پس از Try اجرا نمی‌شود
قطعه کد زیر را در نظر بگیرد:

public class shutDownHooksDemo {
    public static void main(String[] args) {
        for(int i=0;i<5;i++)
        {
            try {
                if(i==4) {
                    System.out.println("Inside Try Block.Exiting without executing Finally block.");
                    System.exit(0);
                }
            }
            finally {
                System.out.println("Inside Finally Block.");
            }
        }
    }
}
با بررسی این قطعه کد شاید فکر کنید که println درون بلوک finally 5 بار اجرا می‌شود، اما اگر برنامه را اجرا کنید، متوجه خواهید شد که بلوک finally تنها چهار بار اجرا می‌شود. در اجرای پنجم تابع exit فراخوانی می‌شود و در نتیجه finally هرگز برای بار پنجم فراخوانی نخواهد شد. دلیل این مسئله آن است که System.exit اجرای همه نخ‌های در حال اجرا از جمله نخ کنونی را متوقف می‌کند. حتی بلوک finally پس از try نیز در صورت اجرای exit اجرا نخواهد شد.

هنگامی که System.exit فراخوانی می‌شود، JVM وظایف پاک‌سازی پیش از خاموشی را اجرا می‌کند. بدین ترتیب ابتدا همه قلاب‌های shutdown که با استفاده از قلاب Runtime.addShutdownHook ثبت شده‌اند را اجرا می‌کند. این حالت مفیدی است زیرا منابع بیرونی به JVM را آزادسازی می‌کند.

دلیل دیگر این موضوع با Finalizer-ها مرتبط است که یا System.runFinalizersOnExit و یا Runtime.runFinalizersOnExit هستند. استفاده از Finalizer-ها مدت‌های زیادی است که منسوخ شده است. Finalizer-ها تنها می‌توانند روی اشیای زنده در زمانی که از سوی نخ‌های دیگر دست‌کاری می‌شوند اجرا گردند. به این ترتیب نتایج غیر قابل پیش‌بینی و یا حتی بن‌بست رخ می‌دهد.

public class shutDownHooksDemo {
 
    public static void main(String[] args) {
            for(int i=0;i<5;i++)
            {
                    final int final_i = i;
                    try {
                            Runtime.getRuntime().addShutdownHook(
                                            new Thread() {
                                            public void run() {
                                            if(final_i==4) {
                                            System.out.println("Inside Try Block.Exiting without executing Finally block.");
                                            System.exit(0);
                                            }
                                            }
                                            });
                    }
                    finally {
                            System.out.println("Inside Finally Block.");
                    }
 
            }
    }
}
بررسی فرد بودن
خطوط کد زیر را بررسی کرده و بگویید آیا این کد می‌تواند فرد بودن یک عدد را با دقت پیش‌بینی کند؟

public boolean oddOrNot(int num) {
    return num % 2 == 1;
}
این خطوط کد صحیح به نظر می‌رسند، اما در یک‌چهارم موارد نتایج نادرستی بازگشت می‌دهند. اگر یک عدد فرد منفی را در نظر بگیریم، باقیمانده تقسیم بر 2 عدد 1 نخواهد بود. بنابراین نتیجه بازگشتی نادرست خواهد بود که نتیجه اشتباهی است. برای اصلاح این مشکل، کد را به صورت زیر بازنویسی می‌کنیم:

public boolean oddOrNot(int num) {
    return (num & 1) != 0;
}
با استفاده از کد فوق نه تنها مشکل اعداد منفی حل می‌شود، بلکه کد به مقدار زیادی بهینه‌تر نیز شده است. از آنجا که عملیات حسابی و منطقی بسیار سریع‌تر از ضرب و تقسیم هستند، نتایج در قطعه کد فوق با سرعت بسیار بالاتری اجرا می‌شوند.

اختلاف بین گیومه تکی و دوبل
به کد زیر توجه کنید:

public class Haha {
    public static void main(String args[]) {
    System.out.print("H" + "a");
    System.out.print('H' + 'a');
    }
}
در این کد به نظر می‌رسد که باید مقدار HaHa بازگشت یابد، اما در عوض مقدار Ha169 بازگشت خواهد یافت. دلیل این مسئله آن است که در صورت استفاده از گیومه‌های دوبل، کاراکترها مانند رشته تصور می‌شوند، اما زمانی که از گیومه تکی استفاده کنیم، عملوندهای با ارزش char از طریق فرایندی به نام «تبدیل اولیه عریض‌سازی» (widening primitive conversion) به مقادیر int تبدیل می‌شوند. پس از تبدیل عدد صحیح، اعداد مورد نظر اضافه شده و مقدار 169 بازگشت می‌یابد.

اجتناب از نشت حافظه با ترفندهای ساده
نشت حافظه در اغلب موارد موجب کاهش عملکرد نرم‌افزار می‌شود. از آنجا که جاوا اقدام به مدیریت خودکار حافظه می‌کند، توسعه‌دهندگان کنترل زیادی روی آن ندارند. اما با این حال برخی رویه‌های استاندارد وجود دارند که می‌توانند برای حفاظت در برابر نشت حافظه مورد استفاده قرار گیرند.

همیشه وقتی کوئری دیتابیس پایان یافت، اتصال پایگاه داده را آزاد کنید.
همواره تلاش کنید بلوک Finally را مورد استفاده قرار دهید.
وهله‌های ذخیره شده در جدول‌های استاتیک را همواره آزاد کنید.
جلوگیری از بروز بن‌بست در جاوا
«بن‌بست‌ها» (Deadlocks) به دلایل مختلفی رخ می‌دهند. هیچ دستورالعمل واحدی برای جلوگیری از بن‌بست وجود ندارد. به طور معمول بن‌بست‌ها زمانی رخ می‌دهند که اشیای همگام‌سازی‌شده منتظر یک قفل روی منبعی باشند که از سوی شیء همگام‌سازی‌شده دیگری قفل شده است.

برنامه زیر را اجرا کنید تا به طور عملی با یک بن‌بست آشنا شوید. این بن‌بست به این دلیل رخ می‌دهد که هر دو نخ منظر منبعی هستند که توسط نخ دیگری اشغال شده است. هر دوی این نخ‌ها در حالت انتظار می‌مانند و هیچ کدام آزاد نمی‌شوند.

public class DeadlockDemo {
   public static Object addLock = new Object();
   public static Object subLock = new Object();
 
   public static void main(String args[]) {
 
      MyAdditionThread add = new MyAdditionThread();
      MySubtractionThread sub = new MySubtractionThread();
      add.start();
      sub.start();
   }
private static class MyAdditionThread extends Thread {
      public void run() {
         synchronized (addLock) {
        int a = 10, b = 3;
        int c = a + b;
            System.out.println("Addition Thread: " + c);
            System.out.println("Holding First Lock...");
            try { Thread.sleep(10); }
            catch (InterruptedException e) {}
            System.out.println("Addition Thread: Waiting for AddLock...");
            synchronized (subLock) {
               System.out.println("Threads: Holding Add and Sub Locks...");
            }
         }
      }
   }
   private static class MySubtractionThread extends Thread {
      public void run() {
         synchronized (subLock) {
        int a = 10, b = 3;
        int c = a - b;
            System.out.println("Subtraction Thread: " + c);
            System.out.println("Holding Second Lock...");
            try { Thread.sleep(10); }
            catch (InterruptedException e) {}
            System.out.println("Subtraction  Thread: Waiting for SubLock...");
            synchronized (addLock) {
               System.out.println("Threads: Holding Add and Sub Locks...");
            }
         }
      }
   }
}
